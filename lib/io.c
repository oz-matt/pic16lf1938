
#include <xc.h>

#include <stdint.h>

#include <io.h>
#include <ubxcmd.h>
#include <eusart.h>

#define _XTAL_FREQ  2000000

static void setup_io(void) {
    TRISA =     0b11000110;
    ANSELA =    0b00000100; // RA2 is VCOMP, the analog battery voltage
    TRISB =     0b00110100;
    TRISC =     0b10100001;
}

static void setup_fvrc(void) {
    CM1CON0 =   0x96;
        // Enable comparator, inverting, fast speed,
        // hysteresis enabled (45mV), asynchronous mode,
        // comparison level is 1.024V
    CM1CON1 =   0x20;
        // No interrupt generated by comparator, pos input
        // set to FVR, neg input set to C12IN0- (RA0)
    FVRCON =    0xC4;

    while (!FVRRDY);

}

static void eusart_init(void) {
    SP1BRGL =   0x0C;
        // Put 12(base 10) into SPBRGL. Now we can
        // have a ~9600 baud

    BRGH = 1;
    SYNC = 0;
    BRG16 = 0;
            // SYNC = 0, BRG16 = 0 and BRGH = 1, this
            // selects 8-bit/Asynchronous with a baud of
            // Fosc/(16(n+1)) where n is the value of SPBRG
            // (set above to 12). The resulting baud is ~9600
            // since 2000000/208 ~= 9600
    SPEN = 1;       // enable serial port
    CREN = 1;       // enable serial receiver
    TXEN = 1;       // enable transmits on serial port

}

static void i2c_init(void) {
    SSPADD =    0x04;       // configure I2C SCL for 31kHz/4 = 7.75kHz
    SSPCON1 =   0x28;       // configure for Master I2C
    SSPSTAT =   0x00;       // enable 'slew rate'

    TRISC =    0x18;       // configure SDA and SCL as _inputs_ (RC3 and RC4)
}

static void setup_interrupts (void) {
    RCIE = 0;
    TMR0IE = 0;
    PEIE = 1;
    GIE = 1;
}

static void timer0_init(void) {
    TMR0 = 0;
    TMR0CS = 0; // Use internal clock (FOSC/4 = 500000c/sec)
    TMR0SE = 0;
    PSA = 0; // Assign prescaler to timer0
    PS0 = 1;
    PS1 = 1; // Divide the TMR0CS clock by 256. So now ~1900 ticks occur per sec.
    PS2 = 1;
}

static void pwm_init(void) {
    // TRISC taken care of above.
    CCP1CON= 0x0C;
    CCP2CON= 0x0C;
    //CCP4CON= 0x0C;
    PR2 = 0x17;
    T2CON = 0x04;

    set_led_duty(RED, 0);
    set_led_duty(GREEN, 0);
    set_led_duty(BLUE, 0);

    TMR2ON = 1;
}

//rc2 = ccp1 = red
//rc1 = ccp2 = green
//rb0 = ccp4 = blue

void set_led_duty(uint8_t color, uint16_t duty) {
    switch (color) {
        case RED:
            CCP1CON |= (duty & 2) << 4;
            CCP1CON |= (duty & 1) << 4;
            CCPR1L = duty >> 2;
            break;
        case GREEN:
            CCP2CON |= (duty & 2) << 4;
            CCP2CON |= (duty & 1) << 4;
            CCPR2L = duty >> 2;
            break;
        case BLUE:
            //CCPR4L = duty >> 2;
            //CCP4CON &= 0xCF;
            //CCP4CON |= (0x30 & (duty << 4));
            break;
    }
}

bool is_usb_plugged_in (void) {
    return (PORTC & USBON);
}

bool is_tc_high  (void) {
    return (PORTB & TC);
}

void blink (void) {
    #asm
        BANKSEL	        PORTE
        movlw           0x02
        movwf           PORTE
    #endasm

    __delay_ms(200);

    #asm
        BANKSEL	        PORTE
        movlw           0x00
        movwf           PORTE
    #endasm
}

bool is_nrfcomplete_high (void) {
    return (PORTA & NRFCOMPLETELV);
}

void pic_init (void) {

    OSCCON = 0x60; // Set Internal Oscillator frequency to 2MHz

    setup_io();
    setup_fvrc();

    WDTCON =    0x1C;
        // Watchdog Timer now set to reset MCU
        // after a 16s idle (with no CLRWDT instruction)

    eusart_init();
    i2c_init();
    timer0_init();
    setup_interrupts();
    pwm_init();
    PULL_EEPROM_MASTER_SEL_LOW(); // Lets PIC16 access EEPROM
}
